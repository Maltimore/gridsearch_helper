#!/usr/bin/env python
import sys
import os
from argparse import Namespace
import shutil
import pathlib
import copy
import subprocess
import datetime
import platform
import warnings
import itertools

import click
import yaml


@click.command()
@click.option('--path',
              type=str,
              required=True,
              help='Output directory.')
@click.option('--launch-script',
              type=str,
              default='cluster/SLURM_entry.sh',
              help=(
                  'Default is ./cluster/SLURM_entry.sh. '
                  'Path to the script that should be run. '
                  'You should take the example script at SLURM/SLURM_entry.sh and '
                  'modify it to your needs. '
                  'You can then place your modified copy of SLURM_entry.sh (possibly renamed) '
                  'and place it somewhere on your system. '
                  'Then, provide the path to that script here.'
              ))
@click.option('--params-path',
              type=str,
              default='parameters.yaml',
              help='Default is ./parameters.yaml. Path to parameters file.')
@click.option('--taskrange-begin',
              type=int,
              default=1,
              help='Default is 1.')
@click.option('--taskrange-end',
              type=int,
              default=1,
              help=(
                  'Default is 1. '
                  'If (taskrange-end - taskrange-begin) = 1, this will be a normal (non-array) job.'
              ))
@click.option('--job-name',
              default=None,
              type=str,
              help='Default is the output directory of --path as the job name.')
@click.option('--action',
              default='launch',
              type=click.Choice(('launch', 'setup', 'cleanup')),
              help=(
                  'As an enduser, you do not have to worry about this option. '
                  'It is for internal use only.'
              ))
def main(**kwargs):
    args = Namespace(**kwargs)

    if args.action == 'setup':
        return setup()
    elif args.action == 'cleanup':
        return cleanup()

    args.path = os.path.abspath(args.path)
    args.launch_script = os.path.abspath(args.launch_script)
    args.params_path = os.path.abspath(args.params_path)
    # job_name
    if args.job_name is None:
        args.job_name = os.path.basename(args.path)
        print(f'Job name set to {args.job_name}')

    if os.path.exists(args.path):
        print(f"Output directory {args.path} already exists, "
              "should we continue?")
        if not input('[y to continue]') == 'y':
            sys.exit('Ok, no job started')
    else:
        os.makedirs(args.path)

    array_job = True if args.taskrange_end - args.taskrange_begin > 0 else False
    # copy the params file to the output folder, regardless of whether this is an
    # array-job or not. If it is an array-job, we will later copy appropriate
    # params files into each output directory (for each job)
    shutil.copyfile(args.params_path, os.path.join(args.path, 'parameters.yaml'))

    # assign hyperparams for each point on the grid and create yaml files for each job
    if array_job:
        with open(pathlib.Path(args.params_path), 'r') as fd:
            params = yaml.safe_load(fd)
        for job_idx in range(args.taskrange_begin, args.taskrange_end + 1):
            job_output_path = os.path.join(args.path, 'job_outputs', str(job_idx).zfill(5))
            os.makedirs(job_output_path, exist_ok=True)
            job_params = assign_hyperparams(job_idx, copy.deepcopy(params))
            with open(os.path.join(job_output_path, 'parameters.yaml'), "w") as fd:
                yaml.dump(job_params, fd)

    # copy the repository
    repository_copy_path = os.path.join(args.path, 'repository')
    if os.path.exists(repository_copy_path):
        shutil.rmtree(repository_copy_path)
    print(f'Making repository directory {repository_copy_path}')
    os.makedirs(repository_copy_path)

    print('Creating archive of git repository, including tracked changes '
          '(but not untracked changes)')
    # when the user is not in the git root directory and we perform git
    # archive, only the contents of the current directory are put into the
    # archive capture_output=True checks the stdout and stderr of a command
    # text=True transforms to proper text (utf-8 presumably)
    # rstrip removes whitespace from the end of the string (in our case, a newline character)
    git_root_directory = subprocess.run(
        ['git', 'rev-parse', '--show-toplevel'],
        capture_output=True,
        text=True
    ).stdout.rstrip()
    git_status_clean = not os.system('git diff-index --quiet HEAD')
    if not git_status_clean:
        # git status is dirty, create archive from stash
        # create a stash and save the hash
        stash_hash = subprocess.run(
            ['git', 'stash', 'create'],
            capture_output=True,
            text=True
        ).stdout.rstrip()
        command = [
            'git', 'archive',
            '-o', os.path.join(args.path, 'temporary_git_stash_archive.tar'),
            stash_hash,
            git_root_directory
        ]
        subprocess.run(command)
    else:
        # git status is clean, create archive from HEAD
        os.system(
            f'git archive -o {args.path}/temporary_git_stash_archive.tar HEAD {git_root_directory}'
        )
    print(f'Unpacking git archive to {repository_copy_path}')
    os.system(f'tar -xf {args.path}/temporary_git_stash_archive.tar -C {repository_copy_path}')
    os.system(f'rm {args.path}/temporary_git_stash_archive.tar')
    print(f'Switching to repository directory {repository_copy_path}')
    os.chdir(repository_copy_path)
    print(f'Now in {os.getcwd()}')

    qsub_command = ([
        'sbatch',
        f'--export=ALL,LAUNCH_SCRIPT={__file__},OUTPUT_PATH={args.path}',
        f'--output={args.path}/job_outputs/%5a/sdout',
        f'--error={args.path}/job_outputs/%5a/sderror',
        f'--job-name={args.job_name}',
        f'--array={args.taskrange_begin}-{args.taskrange_end}',
        args.launch_script
    ])
    print('Running the following qsub command now:')
    print(qsub_command)
    subprocess.run(qsub_command)


def setup():
    start_time = datetime.datetime.now()
    print(f"start time: {start_time}")
    run_info = {
        "start_time": str(start_time),
        "git_hash": get_git_info()["git_hash"],
        "git_status": get_git_info()["git_status"],
        "hostname": platform.uname()[1],
        "run_finished": False,
        "task_id": int(os.environ['SLURM_ARRAY_TASK_ID']),
        "random_seed": int(os.environ['RANDOM_SEED']),
    }
    with open(pathlib.Path(os.environ['OUTPUT_PATH'], 'run_info.yaml'), "w") as fd:
        yaml.dump(run_info, fd)


def cleanup():
    with open(pathlib.Path(os.environ['OUTPUT_PATH'], 'run_info.yaml'), 'r') as fd:
        run_info = yaml.safe_load(fd)
    end_time = datetime.datetime.now()
    run_time_seconds = (
        end_time - datetime.datetime.strptime(run_info['start_time'], '%Y-%m-%d %H:%M:%S.%f')
    ).seconds
    print(f"End time : {end_time}")
    print(f"Run time (seconds): {run_time_seconds}", flush=True)
    run_info["end_time"] = str(end_time)
    run_info["run_time_seconds"] = run_time_seconds
    run_info["run_finished"] = True
    with open(pathlib.Path(os.environ['OUTPUT_PATH'], 'run_info.yaml'), "w") as fd:
        yaml.dump(run_info, fd)


def flatten_dict(dictionary):
    """
    This function recursively flattens an arbitrarily nested dictionary.
    The keys into the flattened dictionary are tuples of the form
    (key, sub_key, sub_sub_key..)
    :param dictionary: (possibly nested) dict
    """
    def flatten_recursive(flat_tuple, dictionary, flattened):
        for key, value in dictionary.items():
            new_flat_tuple = flat_tuple + (key,)
            if isinstance(value, dict):
                flattened = flatten_recursive(new_flat_tuple, value, flattened)
            else:
                flattened[new_flat_tuple] = value
        return flattened

    flattened = {}
    return flatten_recursive(tuple(), dictionary, flattened)


def assign_hyperparams(id_, params):
    """assign_hyperparameters
    Maps an index to a hyperparameter combination. In params, values that are lists
    are interpreted to be those for which different combinations should be tested.

    :param id_: scalar, indicates whic parameter combination to assign
    :param params: dict holding the hyperparameters.
    :returns params: returns a copy of params with list-values replaced by
        list items corresponding to the relevant hyperparameter combination.
    """
    new_params = copy.deepcopy(params['default'])
    flattened = flatten_dict(params['gridsearch'])
    flattened_keys_repeated = [list(itertools.repeat(subkey, len(flattened[subkey]))) for subkey in flattened.keys()]
    key_combos = list(itertools.product(*flattened_keys_repeated))
    param_combos = list(itertools.product(*flattened.values()))
    idx_into_combos = (id_ - 1) % len(param_combos)
    key_combo = key_combos[idx_into_combo]
    param_combo = param_combos[idx_into_combo]
    for key_idx, key in enumerate(key_combo):
        temp_dict = new_params
        for subkey in key[:-1]:
            temp_dict = temp_dict[subkey]
        temp_dict[key[-1]] = param_combo[key_idx]
    return new_params


def get_git_info():
    try:
        return_dict = {
            "git_hash": subprocess.check_output(['git', 'rev-parse', 'HEAD']
                                                ).decode('utf-8').strip('\n'),
            "git_status":  subprocess.check_output(['git', 'status', '--porcelain']
                                                   ).decode('utf-8'),
        }
    except Exception:
        warnings.warn('\nWarning! Failed to get git revision hash!\n')
        return_dict = {
            "git_hash": "failed_to_get",
            "git_status": "failed_to_get"
        }
    return return_dict


if __name__ == "__main__":
    main()
